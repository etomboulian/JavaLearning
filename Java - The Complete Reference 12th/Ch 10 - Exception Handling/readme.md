(258)

# Chapter 10 - Exception Handling

Here we look at Java's exception handling mechanism. An exception is an abnormal condition that arises in a code sequence at run time. In other words an exception is a run-time error.

## Exception Handling Fundamentals

A Java exception is an object that describes an error condition that has occurred in a piece of code. When an exceptional condition arises, an object representing that exception is created and _thrown_ in the method that caused the error. That method may choose to handle the exception itself, or pass it on; however at somepoint an exception will be _caught_ and processed.

Exceptions thrown by Java related to fundamental errors that violate the rules of the Java language or the constraints of the Java execution environment. Manually generated exceptions are typically used to report some error condition to the caller of a method.

Java exception handling is managed via five keywords: **try**, **catch**, **throw**, **throws**, and **finally**.

Program statements that you want to monitor for exceptions are contained within a try block. If an exception occurrs within the try block, it is thrown. Your code can catch this exception using catch and handle it in some rational manner.

Any excption that is thrown out of a method must be specified as such by a throws clause. Any code that must be executed after a try block completes is put into a finally block

The general form of an exception-handling block is

```java
try {
    // block of code to monitor for errors
} catch(ExceptionType1 exOb) {
    // exception handler for ExceptionType1
} catch (ExceptionType2 exOb) {
    // exception handler for ExceptionType2
} finally {
    // block of code to be executed after try block ends
}
```

Where ExceptionType is the type of exception that has occurred.

## Exception Types

All exception types are subclasses of the built in class Throwable. Thus, Throwable is at the top of the exception class hierarchy. Immediately below Throwable are two subclasses that partition exceptions into two distinct branches.

One branch is headed by Exception. This is the class that we will subclass to create our own custom exception types. One important subclass of Exception is RuntimeException. Exceptions of this type are automatically defined for the programs that you write and include things such as divide by zero and invalid array indexing.

The other branch is topped by Error, which defines exceptions that are not expected to be caught under normal circumstances by your program. Exceptions of type Error are used by the Java run-time system to indicate errors having to do with the run-time environment. StackOverflow is such an example. These are typically in response to catastrophic failures that cannot be handled by the program.

- Throwable
  - Exception
    - RuntimeException
  - Error

## Uncaught Exceptions

Before we start handling exceptions we should start by seeing what happens when we don't handle them. [Exc0](code/Exc0.java)

When the Java runtime detects the divide by zero, it constructs a new exception object and then throws this exception. This causes the program to stop immediately since we have not caught the exception.

Any exception that is not caught by your program will ultimately be processed by the default handler, which is provided by the Java runtime system. The default handler displays a string describing the exception, prints a stack trace from the point at which the exception happened, and terminates the program.

The stack trace will always show the sequence of method invocations that led up to the error. See another version in [Exc1](code/Exc1.java) which adds another method layer and notice that the stack trace includes all of the method calls leading up to the exception.

## Using try and catch

Most often we want to handle an exception ourselves. Doing so provides two benefits

1. It allows you to fix the error
2. It prevents the program from automatically terminating

To guard against and handle a run-time error, enclose the code that you want to monitor inside a **try** block. Immediately following the **try** block, include a **catch** clause that spefies the exception type that you wish to catch.

In the next example [Exc2](code/Exc2.java) we modify the prior program to catch the **ArithmaticException** that is generated by the division-by-zero error. Notice that the call to **println()** inside the try block is never executed. Once an exception is thrown, program control transfers out of the try block into the **catch** block.

A **try** and **catch** statement form a unit. The scope of a **catch** clause is restricted to those statements specified specified by the immediately preceeding try statement. In otherwords a catch belongs to a try and will not catch exceptions from other try blocks.

The goal of the catch clause should be to resolve the exceptional condition and then continue on as if the error had not happened. The next example uses the try-catch to catch and handle the divide by zero error [HandleError](code/HandleError.java) The program then continues to completion.

### Displaying the Description of an Exception

**Throwable** overrides the **toString()** method (defined by **Object**) so that it returns a string containing a description of the exception. The message can be printed using a **println()** statement by simply passing the exception as an argument. We could rewrite the catch block in the last program as

```java
catch (ArithmeticException e) {
    System.out.println("Exception: " + e);
    a = 0;  // set a to zero and continue
}
```

Then each divide by zero error displays the following message:

Exception: java.lang.ArithmeticException: / by zero

## Multiple Catch Clauses

In some cases more than one exception can be raised by a single piece of code. To handle this type of situation you can specify two or more catch clauses, each catching a different type of exception. When an exception is thrown, each catch statement is inspected in order and the first one whose type matches that of the exception is executed. After one **catch** statement executes, the others are bypassed, and execution continues after the **try** / **catch** block

The next example [MultipleCatches](code/MultipleCatches.java) traps two different exception types. It will ensure that the program can survive either a divide by zero error or an array index out of bounds error.

When you use multiple catch statements, it is important to remember that exception subclasses must come before any of their supercalsses. This is because a catch statement that uses a superclass will catch exceptions of that type plus any of its subclasses. Thus a subclass would never be reached if it came after its superclass. Further, in Java unreachable code is an error.

If you were to catch Exception before Arithmetic Exception in the previous example then ArithmeticException would never be reach ed since Exception will handle all Exception based errors. To fix this reverse the order of the catch statements.

## Nested try Statements

The **try** statement can be nested. Each time a **try** statemetn is entered, teh context of that exception is pushed onto the stack. If an inner try statement does not have a catch handler, then the stack is unwound and the next try statement's **catch** handlers are inspected for a match. This process continues until one of the **catch** statements succeeds, or until all of the nested try statements are exhaused. If no catch matches, then the Java run-time system will handle the exception. [NestTry](code/NestTry.java)

## throw

## throws

## finally

## Java's built in Exceptions

## Creating your own Exceptions

## Chained Exceptions

## Three Additional Exception Features

## Using Exceptions

(277)
